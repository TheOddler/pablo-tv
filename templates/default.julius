// Helpers
function throttle(func, timeout = 50) {
  let timer;
  let latestFunc;
  return (...args) => {
    latestFunc = func;
    if (!timer) {
      timer = setTimeout(() => { latestFunc.apply(this, args); timer = null; }, timeout);
    }
  };
}

function sendAction(action) {
  fetch("@{HomeR}", {
    method: "POST",
    body: JSON.stringify(action),
    headers: {
      "Content-type": "application/json; charset=UTF-8"
    }
  });
}

(() => {
  /**
   * Code for making the tv listen for "open on tv" messages.
   */
  if ('#{ isTv }' === 'true') {
    const tvWebSocket = new ReconnectingWebSocket('@{HomeR}');
    tvWebSocket.debug = true;
    tvWebSocket.onmessage = function (message) {
      console.log('Received message:', message);
      const url = message.data;
      if (url.startsWith('/')) {
        window.location.replace(url);
      }
      else {
        window.open(url);
      }
    };
  }

})();


(() => {
  /**
   * Code to make arrow keys navigate between focusable elements.
   */

  /**
   * @param {Element} element
  */
  const getMiddle = (element) => {
    let rect = element.getBoundingClientRect();

    // This makes the code pretend an element in a `fixed` container isn't fixed
    // Essentially just a hack to make the header work a bit nicer
    let parent = element;
    while (parent) {
      if (window.getComputedStyle(parent).position === 'fixed') {
        rect = {
          top: rect.top - window.scrollY,
          right: rect.right - window.scrollX,
          bottom: rect.bottom - window.scrollY,
          left: rect.left - window.scrollX,
          width: rect.width,
          height: rect.height,
        };
        break;
      }
      parent = parent.parentElement;
    }

    return {
      x: rect.left + rect.width / 2,
      y: rect.top + rect.height / 2,
    };
  };

  /**
   * @typedef {Object} Point
   * @property {number} x
   * @property {number} y
   */

  /** @typedef {'ArrowUp' | 'ArrowDown' | 'ArrowLeft' | 'ArrowRight'} Direction */

  /**
   * @param {Point} a
   * @param {Point} b
  */
  const getAngle = (a, b) => Math.atan2(b.y - a.y, b.x - a.x);

  /**
   * @param {Point} a
   * @param {Point} b
  */
  const getDistance = (a, b) => Math.hypot(b.x - a.x, b.y - a.y);

  /**
   * @param {number} a
   * @param {number} b
  */
  const getAngleDiff = (a, b) => {
    const diff = b - a;
    const angle = Math.atan2(Math.sin(diff), Math.cos(diff));
    return Math.abs(angle);
  };

  /**
   * @param {Direction} direction
  */
  const dirToAngle = (direction) => {
    switch (direction) {
      case 'ArrowUp':
        return Math.PI * 3 / 2;
      case 'ArrowDown':
        return Math.PI / 2;
      case 'ArrowLeft':
        return Math.PI;
      case 'ArrowRight':
        return 0;
    }
  };

  /**
   * @param {number} a
   * @param {number} b
   * @param {number} t
  */
  const lerp = (a, b, t) => a + (b - a) * t;

  /**
   * @param {number} t
  */
  const ease = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;

  /**
   * @param {number} t
  */
  const easeOut = (t) => 1 - Math.pow(1 - t, 3);

  /**
   * @param {number} x
  */
  const easeInOutElastic = (x) => {
    const c5 = (2 * Math.PI) / 4.5;

    return x === 0
      ? 0
      : x === 1
        ? 1
        : x < 0.5
          ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2
          : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) / 2 + 1;
  }

  /**
   * @param {number} x
  */
  const easeOutBounce = (x) => {
    const n1 = 7.5625;
    const d1 = 2.75;

    if (x < 1 / d1) {
      return n1 * x * x;
    } else if (x < 2 / d1) {
      return n1 * (x -= 1.5 / d1) * x + 0.75;
    } else if (x < 2.5 / d1) {
      return n1 * (x -= 2.25 / d1) * x + 0.9375;
    } else {
      return n1 * (x -= 2.625 / d1) * x + 0.984375;
    }
  }

  /**
   * @param {number} x
  */
  const easeInOutBounce = (x) => {
    return x < 0.5
      ? (1 - easeOutBounce(1 - 2 * x)) / 2
      : (1 + easeOutBounce(2 * x - 1)) / 2;

  }

  const getFocusableElements = () => {
    return Array.from(document.querySelectorAll(
      'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable], audio[controls], video[controls], summary'
    )).filter(el => !el.hasAttribute('tabindex') || el.tabIndex >= 0);
  };


  /** @type {Element | null} */
  let targetElement = null;
  let prevTargetElement = document.body;
  let targetChangeTime = Date.now();
  const highlightingElement = document.createElement('div');
  highlightingElement.id = 'highlighting-element';
  document.body.appendChild(highlightingElement);

  /**
   * @param {Direction} direction
  */
  const moveFocus = (direction) => {
    const currentElement = document.activeElement;
    const focusableElements = getFocusableElements();
    if (focusableElements.length === 0) return;
    if (!currentElement) {
      focusableElements[0].focus();
      return;
    }

    const curPos = getMiddle(currentElement);
    const wantedAngle = dirToAngle(direction);

    let newElement = null;
    let minDistance = Infinity;

    focusableElements.forEach((element) => {
      if (element === currentElement) return;

      const point = getMiddle(element);

      // Only consider elements that are in the direction of the arrow key
      const angle = getAngleDiff(getAngle(curPos, point), wantedAngle);
      const maxAngle = Math.PI / 3;
      if (angle > maxAngle) return;

      // Ignore elements too far off screen (a little off-screen we allow)
      const allowedOffScreen = 0.3;
      if (point.x < -window.innerWidth * allowedOffScreen
        || point.x > window.innerWidth * (1 + allowedOffScreen)
        || point.y < -window.innerHeight * allowedOffScreen
        || point.y > window.innerHeight * (1 + allowedOffScreen)
      ) return;

      // Remember closest element
      const dist = getDistance(curPos, point) * (0.1 + angle / maxAngle); // Scale by the angle so that we prefer elements in the direction
      if (dist < minDistance) {
        minDistance = dist;
        newElement = element;
      }
    });

    if (newElement) {
      newElement.focus();
      newElement.scrollIntoView({
        behavior: "smooth",
        block: "center",
        inline: "center",
      });
      prevTargetElement = targetElement;
      targetElement = newElement;
      targetChangeTime = Date.now();
    }
  };

  const loop = () => {
    const targetRect = targetElement?.getBoundingClientRect() ?? { top: -1000, left: -1000, width: 0, height: 0 };
    const prevRect = prevTargetElement?.getBoundingClientRect() ?? { top: -1000, left: -1000, width: 0, height: 0 };
    const lerpPos = easeOut(Math.min(1, (Date.now() - targetChangeTime) / 300));
    highlightingElement.style.top = lerp(prevRect.top, targetRect.top, lerpPos) + 'px';
    highlightingElement.style.left = lerp(prevRect.left, targetRect.left, lerpPos) + 'px';
    highlightingElement.style.width = lerp(prevRect.width, targetRect.width, lerpPos) + 'px';
    highlightingElement.style.height = lerp(prevRect.height, targetRect.height, lerpPos) + 'px';

    requestAnimationFrame(loop);
  };
  requestAnimationFrame(loop);

  let lastEventTime = 0; // To slow down repeat rate, but still allow key spamming
  document.addEventListener('keydown', (event) => {
    switch (event.key) {
      case 'ArrowUp':
      case 'ArrowDown':
      case 'ArrowLeft':
      case 'ArrowRight':
        // Limit the repeat rate
        if (Date.now() - lastEventTime > 100) {
          moveFocus(event.key);
          lastEventTime = Date.now();
        }
        // Prevent default (that is scrolling),
        // as we scroll to the selected element
        event.preventDefault();
        break;
      // Allow going back with the backspace key for better keyboard navigation
      case 'Backspace':
        history.back();
        event.preventDefault();
        break;
    }
  });
  document.addEventListener('keyup', (event) => {
    switch (event.key) {
      case 'ArrowUp':
      case 'ArrowDown':
      case 'ArrowLeft':
      case 'ArrowRight':
        // Allow spamming by resetting the time
        lastEventTime = 0;
        event.preventDefault();
        break;
    }
  });
})();
